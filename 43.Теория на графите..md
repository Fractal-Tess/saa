_Общи понятия. Представяне на граф. Топологично сортиране. Примери с Python._

# Общи понятия

Графът е математическа структура, която се състои от върхове (или възли) и ръбове, които свързват тези върхове. Графовете се използват за моделиране на различни видове връзки и процеси в реалния свят, като например мрежи, социални връзки, транспортни системи и др.

## Представяне на граф

Графът може да бъде представен по няколко начина, като най-често използваните са:

1. **Матрица на съседство (Adjacency Matrix)**: Това е двумерна матрица, в която редът и колоната представляват върховете на графа. Ако има ръб между два върха, съответната клетка в матрицата съдържа 1 (или теглото на ръба), в противен случай - 0.

2. **Списък на съседство (Adjacency List)**: Това е списък, в който за всеки връх се пази списък от върховете, с които е свързан. Този метод е по-ефективен за редки графове, където броят на ръбовете е много по-малък от максималния възможен.

3. **Списък на ръбове (Edge List)**: Това е списък от всички ръбове в графа, като всеки ръб е представен като двойка върхове.

## Топологично сортиране

Топологичното сортиране е алгоритъм, който се използва за подреждане на върховете в насочен ацикличен граф (DAG) така, че за всеки насочен ръб (u, v), връхът u да се намира преди v в подредбата. Това сортиране е полезно в задачи, където е необходимо да се изпълнят определени действия в определен ред, като например планиране на задачи или компилация на код.

### Пример с Python

Ето пример за топологично сортиране на граф, представен като списък на съседство:


```python
# Пример за топологично сортиране на граф, представен като списък на съседство

# Топологичното сортиране е алгоритъм, който подрежда върховете на насочен граф без цикли (DAG) 
# в линейна последователност, така че за всеки насочен ръб (u, v), връх u да се намира преди v в подредбата.
# Този алгоритъм е особено полезен в задачи като планиране на задачи, компилация на код и други.

# Дефинираме графа като списък на съседство. Ключовете са върховете, а стойностите са списъци от съседни върхове.
graph = {
    'A': ['C'],
    'B': ['C', 'D'],
    'C': ['E'],
    'D': ['F'],
    'E': ['F'],
    'F': []
}

# Функция за топологично сортиране
def topological_sort(graph):
    # Създаваме речник, който ще съхранява броя на входящите ръбове за всеки връх
    in_degree = {u: 0 for u in graph}  # Инициализираме всички върхове с 0 входящи ръбове
    
    # Изчисляваме броя на входящите ръбове за всеки връх
    for u in graph:
        for v in graph[u]:
            in_degree[v] += 1
    
    # Създаваме опашка, която ще съдържа всички върхове без входящи ръбове
    queue = [u for u in graph if in_degree[u] == 0]
    
    # Списък за съхранение на топологичната подредба
    topo_order = []
    
    # Докато опашката не е празна
    while queue:
        # Изваждаме връх от опашката и го добавяме към топологичната подредба
        u = queue.pop(0)
        topo_order.append(u)
        
        # Намаляваме броя на входящите ръбове за всеки съседен връх
        for v in graph[u]:
            in_degree[v] -= 1
            # Ако броят на входящите ръбове стане 0, добавяме върха към опашката
            if in_degree[v] == 0:
                queue.append(v)
    
    # Ако топологичната подредба съдържа всички върхове, връщаме я
    if len(topo_order) == len(graph):
        return topo_order
    else:
        # В противен случай, графът съдържа цикъл и топологично сортиране е невъзможно
        return "Графът съдържа цикъл и не може да бъде топологично сортиран."

# Изпълняваме функцията и извеждаме резултата
sorted_order = topological_sort(graph)
print("Топологична подредба на графа:", sorted_order)
```

### Обяснение на кода:
1. **Графът** е представен като списък на съседство, където всеки връх има списък от съседни върхове.
2. **in_degree** е речник, който съхранява броя на входящите ръбове за всеки връх. Той се инициализира с 0 за всеки връх.
3. **Опашката** съдържа всички върхове, които нямат входящи ръбове. Те са началните точки за топологичното сортиране.
4. **topo_order** е списъкът, който ще съхранява крайната топологична подредба.
5. Алгоритъмът преминава през всички върхове, намалява броя на входящите ръбове за съседните върхове и добавя нови върхове в опашката, ако те нямат входящи ръбове.
6. Ако всички върхове са включени в `topo_order`, графът е успешно сортиран. В противен случай, графът съдържа цикъл и не може да бъде топологично сортиран.

### Примерен изход:
```
Топологична подредба на графа: ['A', 'B', 'C', 'D', 'E', 'F']
```

Този пример демонстрира как топологичното сортиране може да се приложи върху прост граф, като се гарантира, че всички зависимости са изпълнени в правилния ред.
В този пример графът е представен като речник, където ключовете са върховете, а стойностите са списъци от върхове, до които има ръбове. Алгоритъмът за топологично сортиране използва опашка за подреждане на върховете според техните степени на входа. Ако графът съдържа цикъл, топологичното сортиране не е възможно и резултатът ще бъде празен списък.

Този пример илюстрира как може да се приложи топологичното сортиране в практиката, като се използва Python за реализацията на алгоритъма.
